# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse

if TYPE_CHECKING:
    from .client import Client
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class UserActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.User]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await User.prisma().query_raw(
            'SELECT * FROM User WHERE id = $1',
            'bbadfchfja',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.User
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().query_first(
            'SELECT * FROM User WHERE email = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserCreateInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Create a new User record.

        Parameters
        ----------
        data
            User record data
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created User record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a User record from just the required fields
        user = await User.prisma().create(
            data={
                # data to create a User record
                'email': 'ggciceaie',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple User records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of User record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await User.prisma().create_many(
            data=[
                {
                    # data to create a User record
                    'email': 'bbehjachib',
                },
                {
                    # data to create a User record
                    'email': 'cadfabfehe',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single User record.

        Parameters
        ----------
        where
            User filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The deleted User record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().delete(
            where={
                'id': 'dgiiaaijj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique User record.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique(
            where={
                'id': 'bfaiacjjfc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Find a unique User record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique_or_raise(
            where={
                'id': 'eigcfgbif',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple User records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N results
        where
            User filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.User]
            The list of all User records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 User records
        users = await User.prisma().find_many(take=10)

        # find the first 5 User records ordered by the createdAt field
        users = await User.prisma().find_many(
            take=5,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single User record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the updatedAt field
        user = await User.prisma().find_first(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single User record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the stripeCustomerId field
        user = await User.prisma().find_first_or_raise(
            skip=1,
            order={
                'stripeCustomerId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserUpdateInput,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single User record.

        Parameters
        ----------
        data
            User record data specifying what to update
        where
            User filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The updated User record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().update(
            where={
                'id': 'bagcfbhiig',
            },
            data={
                # data to update the User record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserWhereUniqueInput,
        data: types.UserUpsertInput,
        include: Optional[types.UserInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            User filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created or updated User record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().upsert(
            where={
                'id': 'cghideieh',
            },
            data={
                'create': {
                    'id': 'cghideieh',
                    'email': 'cadfabfehe',
                },
                'update': {
                    'email': 'cadfabfehe',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserUpdateManyMutationInput,
        where: types.UserWhereInput,
    ) -> int:
        """Update multiple User records

        Parameters
        ----------
        data
            User data to update the selected User records to
        where
            Filter to select the User records to update

        Returns
        -------
        int
            The total number of User records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all User records
        total = await User.prisma().update_many(
            data={
                'subscriptionId': 'biabhbdai'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> int:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'subscriptionStatus': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> types.UserCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> Union[int, types.UserCountAggregateOutput]:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'monthlyMinutesUsed': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserWhereInput] = None
    ) -> int:
        """Delete multiple User records.

        Parameters
        ----------
        where
            Optional User filter to find the records to be deleted

        Returns
        -------
        int
            The total number of User records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all User records
        total = await User.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserScalarFieldKeys'],
        *,
        where: Optional['types.UserWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAvgAggregateInput'] = None,
        sum: Optional['types.UserSumAggregateInput'] = None,
        min: Optional['types.UserMinAggregateInput'] = None,
        max: Optional['types.UserMaxAggregateInput'] = None,
        having: Optional['types.UserScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserGroupByOutput']:
        """Group User records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar User fields to group records by
        where
            User filter to select records
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserGroupByOutput]
            A list of dictionaries representing the User record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group User records by monthlySessionCount values
        # and count how many records are in each group
        results = await User.prisma().group_by(
            ['monthlySessionCount'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserSettingsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserSettings]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UserSettings.prisma().query_raw(
            'SELECT * FROM UserSettings WHERE id = $1',
            'idghgaicb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserSettings
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UserSettings.prisma().query_first(
            'SELECT * FROM UserSettings WHERE userId = $1',
            'fjfddhigg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserSettingsCreateInput,
        include: Optional[types.UserSettingsInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserSettings record.

        Parameters
        ----------
        data
            UserSettings record data
        include
            Specifies which relations should be loaded on the returned UserSettings model

        Returns
        -------
        prisma.models.UserSettings
            The created UserSettings record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserSettings record from just the required fields
        usersettings = await UserSettings.prisma().create(
            data={
                # data to create a UserSettings record
                'userId': 'hjaecfifb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserSettingsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserSettings records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserSettings record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserSettings.prisma().create_many(
            data=[
                {
                    # data to create a UserSettings record
                    'userId': 'cbbbjbfcii',
                },
                {
                    # data to create a UserSettings record
                    'userId': 'bbejhfidcb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserSettingsWhereUniqueInput,
        include: Optional[types.UserSettingsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserSettings record.

        Parameters
        ----------
        where
            UserSettings filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserSettings model

        Returns
        -------
        prisma.models.UserSettings
            The deleted UserSettings record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usersettings = await UserSettings.prisma().delete(
            where={
                'id': 'bgeecijdgg',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserSettingsWhereUniqueInput,
        include: Optional[types.UserSettingsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserSettings record.

        Parameters
        ----------
        where
            UserSettings filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserSettings model

        Returns
        -------
        prisma.models.UserSettings
            The found UserSettings record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usersettings = await UserSettings.prisma().find_unique(
            where={
                'id': 'bdiicjafbj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserSettingsWhereUniqueInput,
        include: Optional[types.UserSettingsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserSettings record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserSettings filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserSettings model

        Returns
        -------
        prisma.models.UserSettings
            The found UserSettings record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usersettings = await UserSettings.prisma().find_unique_or_raise(
            where={
                'id': 'bgehebiafc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserSettingsWhereInput] = None,
        cursor: Optional[types.UserSettingsWhereUniqueInput] = None,
        include: Optional[types.UserSettingsInclude] = None,
        order: Optional[Union[types.UserSettingsOrderByInput, List[types.UserSettingsOrderByInput]]] = None,
        distinct: Optional[List[types.UserSettingsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserSettings records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserSettings records returned
        skip
            Ignore the first N results
        where
            UserSettings filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserSettings model
        order
            Order the returned UserSettings records by any field
        distinct
            Filter UserSettings records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserSettings]
            The list of all UserSettings records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserSettings records
        usersettings = await UserSettings.prisma().find_many(take=10)

        # find the first 5 UserSettings records ordered by the openaiApiKey field
        usersettings = await UserSettings.prisma().find_many(
            take=5,
            order={
                'openaiApiKey': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserSettingsWhereInput] = None,
        cursor: Optional[types.UserSettingsWhereUniqueInput] = None,
        include: Optional[types.UserSettingsInclude] = None,
        order: Optional[Union[types.UserSettingsOrderByInput, List[types.UserSettingsOrderByInput]]] = None,
        distinct: Optional[List[types.UserSettingsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserSettings record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserSettings filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserSettings model
        order
            Order the returned UserSettings records by any field
        distinct
            Filter UserSettings records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserSettings
            The first UserSettings record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserSettings record ordered by the transcriptionProvider field
        usersettings = await UserSettings.prisma().find_first(
            skip=1,
            order={
                'transcriptionProvider': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserSettingsWhereInput] = None,
        cursor: Optional[types.UserSettingsWhereUniqueInput] = None,
        include: Optional[types.UserSettingsInclude] = None,
        order: Optional[Union[types.UserSettingsOrderByInput, List[types.UserSettingsOrderByInput]]] = None,
        distinct: Optional[List[types.UserSettingsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserSettings record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserSettings filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserSettings model
        order
            Order the returned UserSettings records by any field
        distinct
            Filter UserSettings records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserSettings
            The first UserSettings record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserSettings record ordered by the transcriptionModel field
        usersettings = await UserSettings.prisma().find_first_or_raise(
            skip=1,
            order={
                'transcriptionModel': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserSettingsUpdateInput,
        where: types.UserSettingsWhereUniqueInput,
        include: Optional[types.UserSettingsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserSettings record.

        Parameters
        ----------
        data
            UserSettings record data specifying what to update
        where
            UserSettings filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserSettings model

        Returns
        -------
        prisma.models.UserSettings
            The updated UserSettings record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        usersettings = await UserSettings.prisma().update(
            where={
                'id': 'bghffegacj',
            },
            data={
                # data to update the UserSettings record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserSettingsWhereUniqueInput,
        data: types.UserSettingsUpsertInput,
        include: Optional[types.UserSettingsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserSettings filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserSettings model

        Returns
        -------
        prisma.models.UserSettings
            The created or updated UserSettings record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usersettings = await UserSettings.prisma().upsert(
            where={
                'id': 'bhghchehcc',
            },
            data={
                'create': {
                    'id': 'bhghchehcc',
                    'userId': 'bbejhfidcb',
                },
                'update': {
                    'userId': 'bbejhfidcb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserSettingsUpdateManyMutationInput,
        where: types.UserSettingsWhereInput,
    ) -> int:
        """Update multiple UserSettings records

        Parameters
        ----------
        data
            UserSettings data to update the selected UserSettings records to
        where
            Filter to select the UserSettings records to update

        Returns
        -------
        int
            The total number of UserSettings records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserSettings records
        total = await UserSettings.prisma().update_many(
            data={
                'summaryModel': 'dcgchcbbf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserSettingsWhereInput] = None,
        cursor: Optional[types.UserSettingsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserSettings records present in the database

        Parameters
        ----------
        select
            Select the UserSettings fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserSettings filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserSettingsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserSettings.prisma().count()

        # results: prisma.types.UserSettingsCountAggregateOutput
        results = await UserSettings.prisma().count(
            select={
                '_all': True,
                'chatModel': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserSettingsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserSettingsWhereInput] = None,
        cursor: Optional[types.UserSettingsWhereUniqueInput] = None,
    ) -> types.UserSettingsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserSettingsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserSettingsWhereInput] = None,
        cursor: Optional[types.UserSettingsWhereUniqueInput] = None,
    ) -> Union[int, types.UserSettingsCountAggregateOutput]:
        """Count the number of UserSettings records present in the database

        Parameters
        ----------
        select
            Select the UserSettings fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserSettings filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserSettingsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserSettings.prisma().count()

        # results: prisma.types.UserSettingsCountAggregateOutput
        results = await UserSettings.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserSettingsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserSettingsWhereInput] = None
    ) -> int:
        """Delete multiple UserSettings records.

        Parameters
        ----------
        where
            Optional UserSettings filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserSettings records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserSettings records
        total = await UserSettings.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserSettingsScalarFieldKeys'],
        *,
        where: Optional['types.UserSettingsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserSettingsAvgAggregateInput'] = None,
        sum: Optional['types.UserSettingsSumAggregateInput'] = None,
        min: Optional['types.UserSettingsMinAggregateInput'] = None,
        max: Optional['types.UserSettingsMaxAggregateInput'] = None,
        having: Optional['types.UserSettingsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserSettingsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserSettingsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserSettingsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserSettingsGroupByOutput']:
        """Group UserSettings records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserSettings fields to group records by
        where
            UserSettings filter to select records
        take
            Limit the maximum number of UserSettings records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserSettingsGroupByOutput]
            A list of dictionaries representing the UserSettings record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserSettings records by userId values
        # and count how many records are in each group
        results = await UserSettings.prisma().group_by(
            ['userId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class SessionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Session]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Session.prisma().query_raw(
            'SELECT * FROM Session WHERE id = $1',
            'bdedcabahc',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Session
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Session.prisma().query_first(
            'SELECT * FROM Session WHERE userId = $1',
            'ghfhiafcb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SessionCreateInput,
        include: Optional[types.SessionInclude] = None
    ) -> _PrismaModelT:
        """Create a new Session record.

        Parameters
        ----------
        data
            Session record data
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The created Session record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Session record from just the required fields
        session = await Session.prisma().create(
            data={
                # data to create a Session record
                'userId': 'heejgedji',
                'audioFileName': 'bjgjgibgbf',
                'audioFileUrl': 'bbbgbhfjge',
                'context': 'igbehcbab',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SessionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Session records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Session record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Session.prisma().create_many(
            data=[
                {
                    # data to create a Session record
                    'userId': 'bdadaadhag',
                    'audioFileName': 'bgiggdidbf',
                    'audioFileUrl': 'caaaedabfc',
                    'context': 'bigibebcib',
                },
                {
                    # data to create a Session record
                    'userId': 'bigaiehgcc',
                    'audioFileName': 'beeifcbebf',
                    'audioFileUrl': 'bgcigfahea',
                    'context': 'bcejgaggif',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SessionWhereUniqueInput,
        include: Optional[types.SessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Session record.

        Parameters
        ----------
        where
            Session filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The deleted Session record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        session = await Session.prisma().delete(
            where={
                'id': 'idfjadbcc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SessionWhereUniqueInput,
        include: Optional[types.SessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Session record.

        Parameters
        ----------
        where
            Session filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The found Session record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        session = await Session.prisma().find_unique(
            where={
                'id': 'hgdhbjhhj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SessionWhereUniqueInput,
        include: Optional[types.SessionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Session record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Session filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The found Session record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        session = await Session.prisma().find_unique_or_raise(
            where={
                'id': 'ecjjjfbae',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
        include: Optional[types.SessionInclude] = None,
        order: Optional[Union[types.SessionOrderByInput, List[types.SessionOrderByInput]]] = None,
        distinct: Optional[List[types.SessionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Session records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Session records returned
        skip
            Ignore the first N results
        where
            Session filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Session model
        order
            Order the returned Session records by any field
        distinct
            Filter Session records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Session]
            The list of all Session records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Session records
        sessions = await Session.prisma().find_many(take=10)

        # find the first 5 Session records ordered by the title field
        sessions = await Session.prisma().find_many(
            take=5,
            order={
                'title': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
        include: Optional[types.SessionInclude] = None,
        order: Optional[Union[types.SessionOrderByInput, List[types.SessionOrderByInput]]] = None,
        distinct: Optional[List[types.SessionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Session record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Session filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Session model
        order
            Order the returned Session records by any field
        distinct
            Filter Session records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Session
            The first Session record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Session record ordered by the audioFileName field
        session = await Session.prisma().find_first(
            skip=1,
            order={
                'audioFileName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
        include: Optional[types.SessionInclude] = None,
        order: Optional[Union[types.SessionOrderByInput, List[types.SessionOrderByInput]]] = None,
        distinct: Optional[List[types.SessionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Session record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Session filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Session model
        order
            Order the returned Session records by any field
        distinct
            Filter Session records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Session
            The first Session record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Session record ordered by the audioFileUrl field
        session = await Session.prisma().find_first_or_raise(
            skip=1,
            order={
                'audioFileUrl': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SessionUpdateInput,
        where: types.SessionWhereUniqueInput,
        include: Optional[types.SessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Session record.

        Parameters
        ----------
        data
            Session record data specifying what to update
        where
            Session filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The updated Session record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        session = await Session.prisma().update(
            where={
                'id': 'bhhfibbigf',
            },
            data={
                # data to update the Session record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SessionWhereUniqueInput,
        data: types.SessionUpsertInput,
        include: Optional[types.SessionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Session filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The created or updated Session record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        session = await Session.prisma().upsert(
            where={
                'id': 'ijdbeffgg',
            },
            data={
                'create': {
                    'id': 'ijdbeffgg',
                    'userId': 'bigaiehgcc',
                    'audioFileName': 'beeifcbebf',
                    'audioFileUrl': 'bgcigfahea',
                    'context': 'bcejgaggif',
                },
                'update': {
                    'userId': 'bigaiehgcc',
                    'audioFileName': 'beeifcbebf',
                    'audioFileUrl': 'bgcigfahea',
                    'context': 'bcejgaggif',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SessionUpdateManyMutationInput,
        where: types.SessionWhereInput,
    ) -> int:
        """Update multiple Session records

        Parameters
        ----------
        data
            Session data to update the selected Session records to
        where
            Filter to select the Session records to update

        Returns
        -------
        int
            The total number of Session records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Session records
        total = await Session.prisma().update_many(
            data={
                'context': 'jjfeafhfj'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Session records present in the database

        Parameters
        ----------
        select
            Select the Session fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Session filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SessionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Session.prisma().count()

        # results: prisma.types.SessionCountAggregateOutput
        results = await Session.prisma().count(
            select={
                '_all': True,
                'language': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SessionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
    ) -> types.SessionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SessionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
    ) -> Union[int, types.SessionCountAggregateOutput]:
        """Count the number of Session records present in the database

        Parameters
        ----------
        select
            Select the Session fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Session filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SessionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Session.prisma().count()

        # results: prisma.types.SessionCountAggregateOutput
        results = await Session.prisma().count(
            select={
                '_all': True,
                'detectedLanguage': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SessionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SessionWhereInput] = None
    ) -> int:
        """Delete multiple Session records.

        Parameters
        ----------
        where
            Optional Session filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Session records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Session records
        total = await Session.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SessionScalarFieldKeys'],
        *,
        where: Optional['types.SessionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SessionAvgAggregateInput'] = None,
        sum: Optional['types.SessionSumAggregateInput'] = None,
        min: Optional['types.SessionMinAggregateInput'] = None,
        max: Optional['types.SessionMaxAggregateInput'] = None,
        having: Optional['types.SessionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SessionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SessionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.SessionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.SessionGroupByOutput']:
        """Group Session records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Session fields to group records by
        where
            Session filter to select records
        take
            Limit the maximum number of Session records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SessionGroupByOutput]
            A list of dictionaries representing the Session record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Session records by status values
        # and count how many records are in each group
        results = await Session.prisma().group_by(
            ['status'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TranscriptActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Transcript]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Transcript.prisma().query_raw(
            'SELECT * FROM Transcript WHERE id = $1',
            'cbachdgfce',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Transcript
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Transcript.prisma().query_first(
            'SELECT * FROM Transcript WHERE sessionId = $1',
            'chbfcacbd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TranscriptCreateInput,
        include: Optional[types.TranscriptInclude] = None
    ) -> _PrismaModelT:
        """Create a new Transcript record.

        Parameters
        ----------
        data
            Transcript record data
        include
            Specifies which relations should be loaded on the returned Transcript model

        Returns
        -------
        prisma.models.Transcript
            The created Transcript record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Transcript record from just the required fields
        transcript = await Transcript.prisma().create(
            data={
                # data to create a Transcript record
                'sessionId': 'efggddide',
                'language': 'caficfigfb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TranscriptCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Transcript records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Transcript record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Transcript.prisma().create_many(
            data=[
                {
                    # data to create a Transcript record
                    'sessionId': 'bfidgijfjc',
                    'language': 'ihieecagf',
                },
                {
                    # data to create a Transcript record
                    'sessionId': 'bghfciaafe',
                    'language': 'bgchfhgceh',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TranscriptWhereUniqueInput,
        include: Optional[types.TranscriptInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Transcript record.

        Parameters
        ----------
        where
            Transcript filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Transcript model

        Returns
        -------
        prisma.models.Transcript
            The deleted Transcript record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transcript = await Transcript.prisma().delete(
            where={
                'id': 'cafeiaccbc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TranscriptWhereUniqueInput,
        include: Optional[types.TranscriptInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Transcript record.

        Parameters
        ----------
        where
            Transcript filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Transcript model

        Returns
        -------
        prisma.models.Transcript
            The found Transcript record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transcript = await Transcript.prisma().find_unique(
            where={
                'id': 'gaddfhfh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TranscriptWhereUniqueInput,
        include: Optional[types.TranscriptInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Transcript record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Transcript filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Transcript model

        Returns
        -------
        prisma.models.Transcript
            The found Transcript record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transcript = await Transcript.prisma().find_unique_or_raise(
            where={
                'id': 'gieegcbeg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TranscriptWhereInput] = None,
        cursor: Optional[types.TranscriptWhereUniqueInput] = None,
        include: Optional[types.TranscriptInclude] = None,
        order: Optional[Union[types.TranscriptOrderByInput, List[types.TranscriptOrderByInput]]] = None,
        distinct: Optional[List[types.TranscriptScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Transcript records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Transcript records returned
        skip
            Ignore the first N results
        where
            Transcript filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Transcript model
        order
            Order the returned Transcript records by any field
        distinct
            Filter Transcript records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Transcript]
            The list of all Transcript records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Transcript records
        transcripts = await Transcript.prisma().find_many(take=10)

        # find the first 5 Transcript records ordered by the language field
        transcripts = await Transcript.prisma().find_many(
            take=5,
            order={
                'language': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TranscriptWhereInput] = None,
        cursor: Optional[types.TranscriptWhereUniqueInput] = None,
        include: Optional[types.TranscriptInclude] = None,
        order: Optional[Union[types.TranscriptOrderByInput, List[types.TranscriptOrderByInput]]] = None,
        distinct: Optional[List[types.TranscriptScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Transcript record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Transcript filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Transcript model
        order
            Order the returned Transcript records by any field
        distinct
            Filter Transcript records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Transcript
            The first Transcript record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Transcript record ordered by the duration field
        transcript = await Transcript.prisma().find_first(
            skip=1,
            order={
                'duration': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TranscriptWhereInput] = None,
        cursor: Optional[types.TranscriptWhereUniqueInput] = None,
        include: Optional[types.TranscriptInclude] = None,
        order: Optional[Union[types.TranscriptOrderByInput, List[types.TranscriptOrderByInput]]] = None,
        distinct: Optional[List[types.TranscriptScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Transcript record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Transcript filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Transcript model
        order
            Order the returned Transcript records by any field
        distinct
            Filter Transcript records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Transcript
            The first Transcript record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Transcript record ordered by the id field
        transcript = await Transcript.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TranscriptUpdateInput,
        where: types.TranscriptWhereUniqueInput,
        include: Optional[types.TranscriptInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Transcript record.

        Parameters
        ----------
        data
            Transcript record data specifying what to update
        where
            Transcript filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Transcript model

        Returns
        -------
        prisma.models.Transcript
            The updated Transcript record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        transcript = await Transcript.prisma().update(
            where={
                'id': 'bgcffadich',
            },
            data={
                # data to update the Transcript record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TranscriptWhereUniqueInput,
        data: types.TranscriptUpsertInput,
        include: Optional[types.TranscriptInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Transcript filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Transcript model

        Returns
        -------
        prisma.models.Transcript
            The created or updated Transcript record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transcript = await Transcript.prisma().upsert(
            where={
                'id': 'fcbichhci',
            },
            data={
                'create': {
                    'id': 'fcbichhci',
                    'sessionId': 'bghfciaafe',
                    'language': 'bgchfhgceh',
                },
                'update': {
                    'sessionId': 'bghfciaafe',
                    'language': 'bgchfhgceh',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TranscriptUpdateManyMutationInput,
        where: types.TranscriptWhereInput,
    ) -> int:
        """Update multiple Transcript records

        Parameters
        ----------
        data
            Transcript data to update the selected Transcript records to
        where
            Filter to select the Transcript records to update

        Returns
        -------
        int
            The total number of Transcript records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Transcript records
        total = await Transcript.prisma().update_many(
            data={
                'sessionId': 'bcggadccgf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TranscriptWhereInput] = None,
        cursor: Optional[types.TranscriptWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Transcript records present in the database

        Parameters
        ----------
        select
            Select the Transcript fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Transcript filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TranscriptCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Transcript.prisma().count()

        # results: prisma.types.TranscriptCountAggregateOutput
        results = await Transcript.prisma().count(
            select={
                '_all': True,
                'language': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TranscriptCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TranscriptWhereInput] = None,
        cursor: Optional[types.TranscriptWhereUniqueInput] = None,
    ) -> types.TranscriptCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TranscriptCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TranscriptWhereInput] = None,
        cursor: Optional[types.TranscriptWhereUniqueInput] = None,
    ) -> Union[int, types.TranscriptCountAggregateOutput]:
        """Count the number of Transcript records present in the database

        Parameters
        ----------
        select
            Select the Transcript fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Transcript filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TranscriptCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Transcript.prisma().count()

        # results: prisma.types.TranscriptCountAggregateOutput
        results = await Transcript.prisma().count(
            select={
                '_all': True,
                'duration': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TranscriptCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TranscriptWhereInput] = None
    ) -> int:
        """Delete multiple Transcript records.

        Parameters
        ----------
        where
            Optional Transcript filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Transcript records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Transcript records
        total = await Transcript.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TranscriptScalarFieldKeys'],
        *,
        where: Optional['types.TranscriptWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TranscriptAvgAggregateInput'] = None,
        sum: Optional['types.TranscriptSumAggregateInput'] = None,
        min: Optional['types.TranscriptMinAggregateInput'] = None,
        max: Optional['types.TranscriptMaxAggregateInput'] = None,
        having: Optional['types.TranscriptScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TranscriptCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TranscriptScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TranscriptScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TranscriptGroupByOutput']:
        """Group Transcript records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Transcript fields to group records by
        where
            Transcript filter to select records
        take
            Limit the maximum number of Transcript records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TranscriptGroupByOutput]
            A list of dictionaries representing the Transcript record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Transcript records by id values
        # and count how many records are in each group
        results = await Transcript.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TranscriptSegmentActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.TranscriptSegment]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await TranscriptSegment.prisma().query_raw(
            'SELECT * FROM TranscriptSegment WHERE id = $1',
            'jdcfdcgc',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.TranscriptSegment
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await TranscriptSegment.prisma().query_first(
            'SELECT * FROM TranscriptSegment WHERE transcriptId = $1',
            'cafdaehjid',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TranscriptSegmentCreateInput,
        include: Optional[types.TranscriptSegmentInclude] = None
    ) -> _PrismaModelT:
        """Create a new TranscriptSegment record.

        Parameters
        ----------
        data
            TranscriptSegment record data
        include
            Specifies which relations should be loaded on the returned TranscriptSegment model

        Returns
        -------
        prisma.models.TranscriptSegment
            The created TranscriptSegment record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a TranscriptSegment record from just the required fields
        transcriptsegment = await TranscriptSegment.prisma().create(
            data={
                # data to create a TranscriptSegment record
                'transcriptId': 'gifdddbia',
                'speakerId': 'bchehecef',
                'text': 'jeijcbhfe',
                'startTime': 1964990155.122889,
                'endTime': 255202753.122357,
                'order': 541269159,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TranscriptSegmentCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple TranscriptSegment records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of TranscriptSegment record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await TranscriptSegment.prisma().create_many(
            data=[
                {
                    # data to create a TranscriptSegment record
                    'transcriptId': 'bageiegghg',
                    'speakerId': 'faidicegb',
                    'text': 'bacecgfhbe',
                    'startTime': 872078403.187474,
                    'endTime': 916896761.76926,
                    'order': 820312479,
                },
                {
                    # data to create a TranscriptSegment record
                    'transcriptId': 'jchciaee',
                    'speakerId': 'deeificjd',
                    'text': 'bbcbhebbda',
                    'startTime': 1495896251.20852,
                    'endTime': 860811569.166093,
                    'order': 525761943,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TranscriptSegmentWhereUniqueInput,
        include: Optional[types.TranscriptSegmentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single TranscriptSegment record.

        Parameters
        ----------
        where
            TranscriptSegment filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned TranscriptSegment model

        Returns
        -------
        prisma.models.TranscriptSegment
            The deleted TranscriptSegment record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transcriptsegment = await TranscriptSegment.prisma().delete(
            where={
                'id': 'hdgcajhjg',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TranscriptSegmentWhereUniqueInput,
        include: Optional[types.TranscriptSegmentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique TranscriptSegment record.

        Parameters
        ----------
        where
            TranscriptSegment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TranscriptSegment model

        Returns
        -------
        prisma.models.TranscriptSegment
            The found TranscriptSegment record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transcriptsegment = await TranscriptSegment.prisma().find_unique(
            where={
                'id': 'ejdjahicb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TranscriptSegmentWhereUniqueInput,
        include: Optional[types.TranscriptSegmentInclude] = None
    ) -> _PrismaModelT:
        """Find a unique TranscriptSegment record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            TranscriptSegment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TranscriptSegment model

        Returns
        -------
        prisma.models.TranscriptSegment
            The found TranscriptSegment record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transcriptsegment = await TranscriptSegment.prisma().find_unique_or_raise(
            where={
                'id': 'gdjgigfgc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TranscriptSegmentWhereInput] = None,
        cursor: Optional[types.TranscriptSegmentWhereUniqueInput] = None,
        include: Optional[types.TranscriptSegmentInclude] = None,
        order: Optional[Union[types.TranscriptSegmentOrderByInput, List[types.TranscriptSegmentOrderByInput]]] = None,
        distinct: Optional[List[types.TranscriptSegmentScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple TranscriptSegment records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of TranscriptSegment records returned
        skip
            Ignore the first N results
        where
            TranscriptSegment filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TranscriptSegment model
        order
            Order the returned TranscriptSegment records by any field
        distinct
            Filter TranscriptSegment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.TranscriptSegment]
            The list of all TranscriptSegment records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 TranscriptSegment records
        transcriptsegments = await TranscriptSegment.prisma().find_many(take=10)

        # find the first 5 TranscriptSegment records ordered by the speakerId field
        transcriptsegments = await TranscriptSegment.prisma().find_many(
            take=5,
            order={
                'speakerId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TranscriptSegmentWhereInput] = None,
        cursor: Optional[types.TranscriptSegmentWhereUniqueInput] = None,
        include: Optional[types.TranscriptSegmentInclude] = None,
        order: Optional[Union[types.TranscriptSegmentOrderByInput, List[types.TranscriptSegmentOrderByInput]]] = None,
        distinct: Optional[List[types.TranscriptSegmentScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single TranscriptSegment record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TranscriptSegment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TranscriptSegment model
        order
            Order the returned TranscriptSegment records by any field
        distinct
            Filter TranscriptSegment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TranscriptSegment
            The first TranscriptSegment record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TranscriptSegment record ordered by the speakerName field
        transcriptsegment = await TranscriptSegment.prisma().find_first(
            skip=1,
            order={
                'speakerName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TranscriptSegmentWhereInput] = None,
        cursor: Optional[types.TranscriptSegmentWhereUniqueInput] = None,
        include: Optional[types.TranscriptSegmentInclude] = None,
        order: Optional[Union[types.TranscriptSegmentOrderByInput, List[types.TranscriptSegmentOrderByInput]]] = None,
        distinct: Optional[List[types.TranscriptSegmentScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single TranscriptSegment record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TranscriptSegment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TranscriptSegment model
        order
            Order the returned TranscriptSegment records by any field
        distinct
            Filter TranscriptSegment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TranscriptSegment
            The first TranscriptSegment record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TranscriptSegment record ordered by the text field
        transcriptsegment = await TranscriptSegment.prisma().find_first_or_raise(
            skip=1,
            order={
                'text': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TranscriptSegmentUpdateInput,
        where: types.TranscriptSegmentWhereUniqueInput,
        include: Optional[types.TranscriptSegmentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single TranscriptSegment record.

        Parameters
        ----------
        data
            TranscriptSegment record data specifying what to update
        where
            TranscriptSegment filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned TranscriptSegment model

        Returns
        -------
        prisma.models.TranscriptSegment
            The updated TranscriptSegment record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        transcriptsegment = await TranscriptSegment.prisma().update(
            where={
                'id': 'gfeaahdeh',
            },
            data={
                # data to update the TranscriptSegment record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TranscriptSegmentWhereUniqueInput,
        data: types.TranscriptSegmentUpsertInput,
        include: Optional[types.TranscriptSegmentInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            TranscriptSegment filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned TranscriptSegment model

        Returns
        -------
        prisma.models.TranscriptSegment
            The created or updated TranscriptSegment record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transcriptsegment = await TranscriptSegment.prisma().upsert(
            where={
                'id': 'bjafcgbffc',
            },
            data={
                'create': {
                    'id': 'bjafcgbffc',
                    'transcriptId': 'jchciaee',
                    'speakerId': 'deeificjd',
                    'text': 'bbcbhebbda',
                    'startTime': 1495896251.20852,
                    'endTime': 860811569.166093,
                    'order': 525761943,
                },
                'update': {
                    'transcriptId': 'jchciaee',
                    'speakerId': 'deeificjd',
                    'text': 'bbcbhebbda',
                    'startTime': 1495896251.20852,
                    'endTime': 860811569.166093,
                    'order': 525761943,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TranscriptSegmentUpdateManyMutationInput,
        where: types.TranscriptSegmentWhereInput,
    ) -> int:
        """Update multiple TranscriptSegment records

        Parameters
        ----------
        data
            TranscriptSegment data to update the selected TranscriptSegment records to
        where
            Filter to select the TranscriptSegment records to update

        Returns
        -------
        int
            The total number of TranscriptSegment records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all TranscriptSegment records
        total = await TranscriptSegment.prisma().update_many(
            data={
                'startTime': 78746985.139832
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TranscriptSegmentWhereInput] = None,
        cursor: Optional[types.TranscriptSegmentWhereUniqueInput] = None,
    ) -> int:
        """Count the number of TranscriptSegment records present in the database

        Parameters
        ----------
        select
            Select the TranscriptSegment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TranscriptSegment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TranscriptSegmentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TranscriptSegment.prisma().count()

        # results: prisma.types.TranscriptSegmentCountAggregateOutput
        results = await TranscriptSegment.prisma().count(
            select={
                '_all': True,
                'endTime': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TranscriptSegmentCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TranscriptSegmentWhereInput] = None,
        cursor: Optional[types.TranscriptSegmentWhereUniqueInput] = None,
    ) -> types.TranscriptSegmentCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TranscriptSegmentCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TranscriptSegmentWhereInput] = None,
        cursor: Optional[types.TranscriptSegmentWhereUniqueInput] = None,
    ) -> Union[int, types.TranscriptSegmentCountAggregateOutput]:
        """Count the number of TranscriptSegment records present in the database

        Parameters
        ----------
        select
            Select the TranscriptSegment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TranscriptSegment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TranscriptSegmentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TranscriptSegment.prisma().count()

        # results: prisma.types.TranscriptSegmentCountAggregateOutput
        results = await TranscriptSegment.prisma().count(
            select={
                '_all': True,
                'order': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TranscriptSegmentCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TranscriptSegmentWhereInput] = None
    ) -> int:
        """Delete multiple TranscriptSegment records.

        Parameters
        ----------
        where
            Optional TranscriptSegment filter to find the records to be deleted

        Returns
        -------
        int
            The total number of TranscriptSegment records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all TranscriptSegment records
        total = await TranscriptSegment.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TranscriptSegmentScalarFieldKeys'],
        *,
        where: Optional['types.TranscriptSegmentWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TranscriptSegmentAvgAggregateInput'] = None,
        sum: Optional['types.TranscriptSegmentSumAggregateInput'] = None,
        min: Optional['types.TranscriptSegmentMinAggregateInput'] = None,
        max: Optional['types.TranscriptSegmentMaxAggregateInput'] = None,
        having: Optional['types.TranscriptSegmentScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TranscriptSegmentCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TranscriptSegmentScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TranscriptSegmentScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TranscriptSegmentGroupByOutput']:
        """Group TranscriptSegment records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar TranscriptSegment fields to group records by
        where
            TranscriptSegment filter to select records
        take
            Limit the maximum number of TranscriptSegment records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TranscriptSegmentGroupByOutput]
            A list of dictionaries representing the TranscriptSegment record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group TranscriptSegment records by id values
        # and count how many records are in each group
        results = await TranscriptSegment.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class SummaryActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Summary]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Summary.prisma().query_raw(
            'SELECT * FROM Summary WHERE id = $1',
            'ifgaaagff',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Summary
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Summary.prisma().query_first(
            'SELECT * FROM Summary WHERE sessionId = $1',
            'befcddgjce',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SummaryCreateInput,
        include: Optional[types.SummaryInclude] = None
    ) -> _PrismaModelT:
        """Create a new Summary record.

        Parameters
        ----------
        data
            Summary record data
        include
            Specifies which relations should be loaded on the returned Summary model

        Returns
        -------
        prisma.models.Summary
            The created Summary record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Summary record from just the required fields
        summary = await Summary.prisma().create(
            data={
                # data to create a Summary record
                'sessionId': 'bfhdbjjgfd',
                'overview': 'cabdjadaji',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SummaryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Summary records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Summary record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Summary.prisma().create_many(
            data=[
                {
                    # data to create a Summary record
                    'sessionId': 'faajgfadf',
                    'overview': 'biaagcedjc',
                },
                {
                    # data to create a Summary record
                    'sessionId': 'cahhaghecf',
                    'overview': 'bghcbbcidi',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SummaryWhereUniqueInput,
        include: Optional[types.SummaryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Summary record.

        Parameters
        ----------
        where
            Summary filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Summary model

        Returns
        -------
        prisma.models.Summary
            The deleted Summary record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        summary = await Summary.prisma().delete(
            where={
                'id': 'jcgghhgdj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SummaryWhereUniqueInput,
        include: Optional[types.SummaryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Summary record.

        Parameters
        ----------
        where
            Summary filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Summary model

        Returns
        -------
        prisma.models.Summary
            The found Summary record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        summary = await Summary.prisma().find_unique(
            where={
                'id': 'beehgcebbg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SummaryWhereUniqueInput,
        include: Optional[types.SummaryInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Summary record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Summary filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Summary model

        Returns
        -------
        prisma.models.Summary
            The found Summary record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        summary = await Summary.prisma().find_unique_or_raise(
            where={
                'id': 'bhdiaidiaf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SummaryWhereInput] = None,
        cursor: Optional[types.SummaryWhereUniqueInput] = None,
        include: Optional[types.SummaryInclude] = None,
        order: Optional[Union[types.SummaryOrderByInput, List[types.SummaryOrderByInput]]] = None,
        distinct: Optional[List[types.SummaryScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Summary records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Summary records returned
        skip
            Ignore the first N results
        where
            Summary filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Summary model
        order
            Order the returned Summary records by any field
        distinct
            Filter Summary records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Summary]
            The list of all Summary records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Summary records
        summarys = await Summary.prisma().find_many(take=10)

        # find the first 5 Summary records ordered by the overview field
        summarys = await Summary.prisma().find_many(
            take=5,
            order={
                'overview': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SummaryWhereInput] = None,
        cursor: Optional[types.SummaryWhereUniqueInput] = None,
        include: Optional[types.SummaryInclude] = None,
        order: Optional[Union[types.SummaryOrderByInput, List[types.SummaryOrderByInput]]] = None,
        distinct: Optional[List[types.SummaryScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Summary record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Summary filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Summary model
        order
            Order the returned Summary records by any field
        distinct
            Filter Summary records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Summary
            The first Summary record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Summary record ordered by the keyPoints field
        summary = await Summary.prisma().find_first(
            skip=1,
            order={
                'keyPoints': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SummaryWhereInput] = None,
        cursor: Optional[types.SummaryWhereUniqueInput] = None,
        include: Optional[types.SummaryInclude] = None,
        order: Optional[Union[types.SummaryOrderByInput, List[types.SummaryOrderByInput]]] = None,
        distinct: Optional[List[types.SummaryScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Summary record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Summary filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Summary model
        order
            Order the returned Summary records by any field
        distinct
            Filter Summary records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Summary
            The first Summary record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Summary record ordered by the id field
        summary = await Summary.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SummaryUpdateInput,
        where: types.SummaryWhereUniqueInput,
        include: Optional[types.SummaryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Summary record.

        Parameters
        ----------
        data
            Summary record data specifying what to update
        where
            Summary filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Summary model

        Returns
        -------
        prisma.models.Summary
            The updated Summary record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        summary = await Summary.prisma().update(
            where={
                'id': 'deajegcfi',
            },
            data={
                # data to update the Summary record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SummaryWhereUniqueInput,
        data: types.SummaryUpsertInput,
        include: Optional[types.SummaryInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Summary filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Summary model

        Returns
        -------
        prisma.models.Summary
            The created or updated Summary record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        summary = await Summary.prisma().upsert(
            where={
                'id': 'gabahhhjf',
            },
            data={
                'create': {
                    'id': 'gabahhhjf',
                    'sessionId': 'cahhaghecf',
                    'overview': 'bghcbbcidi',
                },
                'update': {
                    'sessionId': 'cahhaghecf',
                    'overview': 'bghcbbcidi',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SummaryUpdateManyMutationInput,
        where: types.SummaryWhereInput,
    ) -> int:
        """Update multiple Summary records

        Parameters
        ----------
        data
            Summary data to update the selected Summary records to
        where
            Filter to select the Summary records to update

        Returns
        -------
        int
            The total number of Summary records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Summary records
        total = await Summary.prisma().update_many(
            data={
                'sessionId': 'cjagadcjg'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SummaryWhereInput] = None,
        cursor: Optional[types.SummaryWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Summary records present in the database

        Parameters
        ----------
        select
            Select the Summary fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Summary filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SummaryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Summary.prisma().count()

        # results: prisma.types.SummaryCountAggregateOutput
        results = await Summary.prisma().count(
            select={
                '_all': True,
                'overview': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SummaryCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SummaryWhereInput] = None,
        cursor: Optional[types.SummaryWhereUniqueInput] = None,
    ) -> types.SummaryCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SummaryCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SummaryWhereInput] = None,
        cursor: Optional[types.SummaryWhereUniqueInput] = None,
    ) -> Union[int, types.SummaryCountAggregateOutput]:
        """Count the number of Summary records present in the database

        Parameters
        ----------
        select
            Select the Summary fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Summary filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SummaryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Summary.prisma().count()

        # results: prisma.types.SummaryCountAggregateOutput
        results = await Summary.prisma().count(
            select={
                '_all': True,
                'keyPoints': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SummaryCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SummaryWhereInput] = None
    ) -> int:
        """Delete multiple Summary records.

        Parameters
        ----------
        where
            Optional Summary filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Summary records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Summary records
        total = await Summary.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SummaryScalarFieldKeys'],
        *,
        where: Optional['types.SummaryWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SummaryAvgAggregateInput'] = None,
        sum: Optional['types.SummarySumAggregateInput'] = None,
        min: Optional['types.SummaryMinAggregateInput'] = None,
        max: Optional['types.SummaryMaxAggregateInput'] = None,
        having: Optional['types.SummaryScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SummaryCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SummaryScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.SummaryScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.SummaryGroupByOutput']:
        """Group Summary records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Summary fields to group records by
        where
            Summary filter to select records
        take
            Limit the maximum number of Summary records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SummaryGroupByOutput]
            A list of dictionaries representing the Summary record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Summary records by id values
        # and count how many records are in each group
        results = await Summary.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ActionItemActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ActionItem]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ActionItem.prisma().query_raw(
            'SELECT * FROM ActionItem WHERE id = $1',
            'bifficggej',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ActionItem
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ActionItem.prisma().query_first(
            'SELECT * FROM ActionItem WHERE summaryId = $1',
            'bgbbaajbic',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ActionItemCreateInput,
        include: Optional[types.ActionItemInclude] = None
    ) -> _PrismaModelT:
        """Create a new ActionItem record.

        Parameters
        ----------
        data
            ActionItem record data
        include
            Specifies which relations should be loaded on the returned ActionItem model

        Returns
        -------
        prisma.models.ActionItem
            The created ActionItem record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ActionItem record from just the required fields
        actionitem = await ActionItem.prisma().create(
            data={
                # data to create a ActionItem record
                'summaryId': 'eegghdhjb',
                'description': 'daafgidjg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ActionItemCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ActionItem records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ActionItem record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ActionItem.prisma().create_many(
            data=[
                {
                    # data to create a ActionItem record
                    'summaryId': 'gdcgcgagj',
                    'description': 'bhceabbgja',
                },
                {
                    # data to create a ActionItem record
                    'summaryId': 'ehabfhegh',
                    'description': 'bcajcajjbc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ActionItemWhereUniqueInput,
        include: Optional[types.ActionItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ActionItem record.

        Parameters
        ----------
        where
            ActionItem filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ActionItem model

        Returns
        -------
        prisma.models.ActionItem
            The deleted ActionItem record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        actionitem = await ActionItem.prisma().delete(
            where={
                'id': 'bfdgheeegf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ActionItemWhereUniqueInput,
        include: Optional[types.ActionItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ActionItem record.

        Parameters
        ----------
        where
            ActionItem filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ActionItem model

        Returns
        -------
        prisma.models.ActionItem
            The found ActionItem record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        actionitem = await ActionItem.prisma().find_unique(
            where={
                'id': 'ececbijji',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ActionItemWhereUniqueInput,
        include: Optional[types.ActionItemInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ActionItem record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ActionItem filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ActionItem model

        Returns
        -------
        prisma.models.ActionItem
            The found ActionItem record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        actionitem = await ActionItem.prisma().find_unique_or_raise(
            where={
                'id': 'cbcfgdcdhf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ActionItemWhereInput] = None,
        cursor: Optional[types.ActionItemWhereUniqueInput] = None,
        include: Optional[types.ActionItemInclude] = None,
        order: Optional[Union[types.ActionItemOrderByInput, List[types.ActionItemOrderByInput]]] = None,
        distinct: Optional[List[types.ActionItemScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ActionItem records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ActionItem records returned
        skip
            Ignore the first N results
        where
            ActionItem filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ActionItem model
        order
            Order the returned ActionItem records by any field
        distinct
            Filter ActionItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ActionItem]
            The list of all ActionItem records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ActionItem records
        actionitems = await ActionItem.prisma().find_many(take=10)

        # find the first 5 ActionItem records ordered by the description field
        actionitems = await ActionItem.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ActionItemWhereInput] = None,
        cursor: Optional[types.ActionItemWhereUniqueInput] = None,
        include: Optional[types.ActionItemInclude] = None,
        order: Optional[Union[types.ActionItemOrderByInput, List[types.ActionItemOrderByInput]]] = None,
        distinct: Optional[List[types.ActionItemScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ActionItem record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ActionItem filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ActionItem model
        order
            Order the returned ActionItem records by any field
        distinct
            Filter ActionItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ActionItem
            The first ActionItem record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ActionItem record ordered by the assignee field
        actionitem = await ActionItem.prisma().find_first(
            skip=1,
            order={
                'assignee': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ActionItemWhereInput] = None,
        cursor: Optional[types.ActionItemWhereUniqueInput] = None,
        include: Optional[types.ActionItemInclude] = None,
        order: Optional[Union[types.ActionItemOrderByInput, List[types.ActionItemOrderByInput]]] = None,
        distinct: Optional[List[types.ActionItemScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ActionItem record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ActionItem filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ActionItem model
        order
            Order the returned ActionItem records by any field
        distinct
            Filter ActionItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ActionItem
            The first ActionItem record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ActionItem record ordered by the deadline field
        actionitem = await ActionItem.prisma().find_first_or_raise(
            skip=1,
            order={
                'deadline': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ActionItemUpdateInput,
        where: types.ActionItemWhereUniqueInput,
        include: Optional[types.ActionItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ActionItem record.

        Parameters
        ----------
        data
            ActionItem record data specifying what to update
        where
            ActionItem filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ActionItem model

        Returns
        -------
        prisma.models.ActionItem
            The updated ActionItem record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        actionitem = await ActionItem.prisma().update(
            where={
                'id': 'fdgjfbhia',
            },
            data={
                # data to update the ActionItem record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ActionItemWhereUniqueInput,
        data: types.ActionItemUpsertInput,
        include: Optional[types.ActionItemInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ActionItem filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ActionItem model

        Returns
        -------
        prisma.models.ActionItem
            The created or updated ActionItem record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        actionitem = await ActionItem.prisma().upsert(
            where={
                'id': 'jcehcdchh',
            },
            data={
                'create': {
                    'id': 'jcehcdchh',
                    'summaryId': 'ehabfhegh',
                    'description': 'bcajcajjbc',
                },
                'update': {
                    'summaryId': 'ehabfhegh',
                    'description': 'bcajcajjbc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ActionItemUpdateManyMutationInput,
        where: types.ActionItemWhereInput,
    ) -> int:
        """Update multiple ActionItem records

        Parameters
        ----------
        data
            ActionItem data to update the selected ActionItem records to
        where
            Filter to select the ActionItem records to update

        Returns
        -------
        int
            The total number of ActionItem records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ActionItem records
        total = await ActionItem.prisma().update_many(
            data={
                'completed': True
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ActionItemWhereInput] = None,
        cursor: Optional[types.ActionItemWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ActionItem records present in the database

        Parameters
        ----------
        select
            Select the ActionItem fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ActionItem filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ActionItemCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ActionItem.prisma().count()

        # results: prisma.types.ActionItemCountAggregateOutput
        results = await ActionItem.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ActionItemCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ActionItemWhereInput] = None,
        cursor: Optional[types.ActionItemWhereUniqueInput] = None,
    ) -> types.ActionItemCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ActionItemCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ActionItemWhereInput] = None,
        cursor: Optional[types.ActionItemWhereUniqueInput] = None,
    ) -> Union[int, types.ActionItemCountAggregateOutput]:
        """Count the number of ActionItem records present in the database

        Parameters
        ----------
        select
            Select the ActionItem fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ActionItem filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ActionItemCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ActionItem.prisma().count()

        # results: prisma.types.ActionItemCountAggregateOutput
        results = await ActionItem.prisma().count(
            select={
                '_all': True,
                'summaryId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ActionItemCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ActionItemWhereInput] = None
    ) -> int:
        """Delete multiple ActionItem records.

        Parameters
        ----------
        where
            Optional ActionItem filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ActionItem records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ActionItem records
        total = await ActionItem.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ActionItemScalarFieldKeys'],
        *,
        where: Optional['types.ActionItemWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ActionItemAvgAggregateInput'] = None,
        sum: Optional['types.ActionItemSumAggregateInput'] = None,
        min: Optional['types.ActionItemMinAggregateInput'] = None,
        max: Optional['types.ActionItemMaxAggregateInput'] = None,
        having: Optional['types.ActionItemScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ActionItemCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ActionItemScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ActionItemScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ActionItemGroupByOutput']:
        """Group ActionItem records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ActionItem fields to group records by
        where
            ActionItem filter to select records
        take
            Limit the maximum number of ActionItem records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ActionItemGroupByOutput]
            A list of dictionaries representing the ActionItem record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ActionItem records by description values
        # and count how many records are in each group
        results = await ActionItem.prisma().group_by(
            ['description'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ChatMessageActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ChatMessage]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ChatMessage.prisma().query_raw(
            'SELECT * FROM ChatMessage WHERE id = $1',
            'bieiidcabj',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ChatMessage
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ChatMessage.prisma().query_first(
            'SELECT * FROM ChatMessage WHERE sessionId = $1',
            'bjcbfcieaa',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ChatMessageCreateInput,
        include: Optional[types.ChatMessageInclude] = None
    ) -> _PrismaModelT:
        """Create a new ChatMessage record.

        Parameters
        ----------
        data
            ChatMessage record data
        include
            Specifies which relations should be loaded on the returned ChatMessage model

        Returns
        -------
        prisma.models.ChatMessage
            The created ChatMessage record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ChatMessage record from just the required fields
        chatmessage = await ChatMessage.prisma().create(
            data={
                # data to create a ChatMessage record
                'sessionId': 'cbaaechiej',
                'role': 'iejbeaaeg',
                'content': 'jcibfcbhf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ChatMessageCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ChatMessage records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ChatMessage record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ChatMessage.prisma().create_many(
            data=[
                {
                    # data to create a ChatMessage record
                    'sessionId': 'chdadcaga',
                    'role': 'jicieifbh',
                    'content': 'fbahdheji',
                },
                {
                    # data to create a ChatMessage record
                    'sessionId': 'cbbheiicgh',
                    'role': 'beabjeejdg',
                    'content': 'bcjhgahffd',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ChatMessageWhereUniqueInput,
        include: Optional[types.ChatMessageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ChatMessage record.

        Parameters
        ----------
        where
            ChatMessage filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ChatMessage model

        Returns
        -------
        prisma.models.ChatMessage
            The deleted ChatMessage record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        chatmessage = await ChatMessage.prisma().delete(
            where={
                'id': 'fbjeiiffa',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ChatMessageWhereUniqueInput,
        include: Optional[types.ChatMessageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ChatMessage record.

        Parameters
        ----------
        where
            ChatMessage filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ChatMessage model

        Returns
        -------
        prisma.models.ChatMessage
            The found ChatMessage record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        chatmessage = await ChatMessage.prisma().find_unique(
            where={
                'id': 'jhgidcgbf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ChatMessageWhereUniqueInput,
        include: Optional[types.ChatMessageInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ChatMessage record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ChatMessage filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ChatMessage model

        Returns
        -------
        prisma.models.ChatMessage
            The found ChatMessage record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        chatmessage = await ChatMessage.prisma().find_unique_or_raise(
            where={
                'id': 'bgjgecfejc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChatMessageWhereInput] = None,
        cursor: Optional[types.ChatMessageWhereUniqueInput] = None,
        include: Optional[types.ChatMessageInclude] = None,
        order: Optional[Union[types.ChatMessageOrderByInput, List[types.ChatMessageOrderByInput]]] = None,
        distinct: Optional[List[types.ChatMessageScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ChatMessage records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ChatMessage records returned
        skip
            Ignore the first N results
        where
            ChatMessage filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ChatMessage model
        order
            Order the returned ChatMessage records by any field
        distinct
            Filter ChatMessage records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ChatMessage]
            The list of all ChatMessage records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ChatMessage records
        chatmessages = await ChatMessage.prisma().find_many(take=10)

        # find the first 5 ChatMessage records ordered by the role field
        chatmessages = await ChatMessage.prisma().find_many(
            take=5,
            order={
                'role': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ChatMessageWhereInput] = None,
        cursor: Optional[types.ChatMessageWhereUniqueInput] = None,
        include: Optional[types.ChatMessageInclude] = None,
        order: Optional[Union[types.ChatMessageOrderByInput, List[types.ChatMessageOrderByInput]]] = None,
        distinct: Optional[List[types.ChatMessageScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ChatMessage record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ChatMessage filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ChatMessage model
        order
            Order the returned ChatMessage records by any field
        distinct
            Filter ChatMessage records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ChatMessage
            The first ChatMessage record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ChatMessage record ordered by the content field
        chatmessage = await ChatMessage.prisma().find_first(
            skip=1,
            order={
                'content': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ChatMessageWhereInput] = None,
        cursor: Optional[types.ChatMessageWhereUniqueInput] = None,
        include: Optional[types.ChatMessageInclude] = None,
        order: Optional[Union[types.ChatMessageOrderByInput, List[types.ChatMessageOrderByInput]]] = None,
        distinct: Optional[List[types.ChatMessageScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ChatMessage record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ChatMessage filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ChatMessage model
        order
            Order the returned ChatMessage records by any field
        distinct
            Filter ChatMessage records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ChatMessage
            The first ChatMessage record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ChatMessage record ordered by the createdAt field
        chatmessage = await ChatMessage.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ChatMessageUpdateInput,
        where: types.ChatMessageWhereUniqueInput,
        include: Optional[types.ChatMessageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ChatMessage record.

        Parameters
        ----------
        data
            ChatMessage record data specifying what to update
        where
            ChatMessage filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ChatMessage model

        Returns
        -------
        prisma.models.ChatMessage
            The updated ChatMessage record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        chatmessage = await ChatMessage.prisma().update(
            where={
                'id': 'bgjcgchib',
            },
            data={
                # data to update the ChatMessage record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ChatMessageWhereUniqueInput,
        data: types.ChatMessageUpsertInput,
        include: Optional[types.ChatMessageInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ChatMessage filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ChatMessage model

        Returns
        -------
        prisma.models.ChatMessage
            The created or updated ChatMessage record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        chatmessage = await ChatMessage.prisma().upsert(
            where={
                'id': 'bacdaibgfa',
            },
            data={
                'create': {
                    'id': 'bacdaibgfa',
                    'sessionId': 'cbbheiicgh',
                    'role': 'beabjeejdg',
                    'content': 'bcjhgahffd',
                },
                'update': {
                    'sessionId': 'cbbheiicgh',
                    'role': 'beabjeejdg',
                    'content': 'bcjhgahffd',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ChatMessageUpdateManyMutationInput,
        where: types.ChatMessageWhereInput,
    ) -> int:
        """Update multiple ChatMessage records

        Parameters
        ----------
        data
            ChatMessage data to update the selected ChatMessage records to
        where
            Filter to select the ChatMessage records to update

        Returns
        -------
        int
            The total number of ChatMessage records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ChatMessage records
        total = await ChatMessage.prisma().update_many(
            data={
                'id': 'dchgibach'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChatMessageWhereInput] = None,
        cursor: Optional[types.ChatMessageWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ChatMessage records present in the database

        Parameters
        ----------
        select
            Select the ChatMessage fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ChatMessage filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ChatMessageCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ChatMessage.prisma().count()

        # results: prisma.types.ChatMessageCountAggregateOutput
        results = await ChatMessage.prisma().count(
            select={
                '_all': True,
                'sessionId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ChatMessageCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChatMessageWhereInput] = None,
        cursor: Optional[types.ChatMessageWhereUniqueInput] = None,
    ) -> types.ChatMessageCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ChatMessageCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChatMessageWhereInput] = None,
        cursor: Optional[types.ChatMessageWhereUniqueInput] = None,
    ) -> Union[int, types.ChatMessageCountAggregateOutput]:
        """Count the number of ChatMessage records present in the database

        Parameters
        ----------
        select
            Select the ChatMessage fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ChatMessage filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ChatMessageCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ChatMessage.prisma().count()

        # results: prisma.types.ChatMessageCountAggregateOutput
        results = await ChatMessage.prisma().count(
            select={
                '_all': True,
                'role': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ChatMessageCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ChatMessageWhereInput] = None
    ) -> int:
        """Delete multiple ChatMessage records.

        Parameters
        ----------
        where
            Optional ChatMessage filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ChatMessage records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ChatMessage records
        total = await ChatMessage.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ChatMessageScalarFieldKeys'],
        *,
        where: Optional['types.ChatMessageWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ChatMessageAvgAggregateInput'] = None,
        sum: Optional['types.ChatMessageSumAggregateInput'] = None,
        min: Optional['types.ChatMessageMinAggregateInput'] = None,
        max: Optional['types.ChatMessageMaxAggregateInput'] = None,
        having: Optional['types.ChatMessageScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ChatMessageCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ChatMessageScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ChatMessageScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ChatMessageGroupByOutput']:
        """Group ChatMessage records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ChatMessage fields to group records by
        where
            ChatMessage filter to select records
        take
            Limit the maximum number of ChatMessage records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ChatMessageGroupByOutput]
            A list of dictionaries representing the ChatMessage record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ChatMessage records by content values
        # and count how many records are in each group
        results = await ChatMessage.prisma().group_by(
            ['content'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class EntityActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Entity]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Entity.prisma().query_raw(
            'SELECT * FROM Entity WHERE id = $1',
            'fchheijjc',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Entity
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Entity.prisma().query_first(
            'SELECT * FROM Entity WHERE userId = $1',
            'cacjdfhejh',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.EntityCreateInput,
        include: Optional[types.EntityInclude] = None
    ) -> _PrismaModelT:
        """Create a new Entity record.

        Parameters
        ----------
        data
            Entity record data
        include
            Specifies which relations should be loaded on the returned Entity model

        Returns
        -------
        prisma.models.Entity
            The created Entity record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Entity record from just the required fields
        entity = await Entity.prisma().create(
            data={
                # data to create a Entity record
                'userId': 'bdbifjhbbi',
                'type': 'cbccbbcdfb',
                'value': 'bacejedaca',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.EntityCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Entity records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Entity record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Entity.prisma().create_many(
            data=[
                {
                    # data to create a Entity record
                    'userId': 'bhbhdahfaj',
                    'type': 'bfjibceaec',
                    'value': 'ibhgcdbgd',
                },
                {
                    # data to create a Entity record
                    'userId': 'badaffhddg',
                    'type': 'bbdbfcfihd',
                    'value': 'cbagggbji',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.EntityWhereUniqueInput,
        include: Optional[types.EntityInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Entity record.

        Parameters
        ----------
        where
            Entity filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Entity model

        Returns
        -------
        prisma.models.Entity
            The deleted Entity record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        entity = await Entity.prisma().delete(
            where={
                'id': 'bchgafhjed',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.EntityWhereUniqueInput,
        include: Optional[types.EntityInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Entity record.

        Parameters
        ----------
        where
            Entity filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Entity model

        Returns
        -------
        prisma.models.Entity
            The found Entity record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        entity = await Entity.prisma().find_unique(
            where={
                'id': 'heffgjdei',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.EntityWhereUniqueInput,
        include: Optional[types.EntityInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Entity record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Entity filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Entity model

        Returns
        -------
        prisma.models.Entity
            The found Entity record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        entity = await Entity.prisma().find_unique_or_raise(
            where={
                'id': 'dahihgbeb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EntityWhereInput] = None,
        cursor: Optional[types.EntityWhereUniqueInput] = None,
        include: Optional[types.EntityInclude] = None,
        order: Optional[Union[types.EntityOrderByInput, List[types.EntityOrderByInput]]] = None,
        distinct: Optional[List[types.EntityScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Entity records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Entity records returned
        skip
            Ignore the first N results
        where
            Entity filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Entity model
        order
            Order the returned Entity records by any field
        distinct
            Filter Entity records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Entity]
            The list of all Entity records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Entity records
        entitys = await Entity.prisma().find_many(take=10)

        # find the first 5 Entity records ordered by the type field
        entitys = await Entity.prisma().find_many(
            take=5,
            order={
                'type': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EntityWhereInput] = None,
        cursor: Optional[types.EntityWhereUniqueInput] = None,
        include: Optional[types.EntityInclude] = None,
        order: Optional[Union[types.EntityOrderByInput, List[types.EntityOrderByInput]]] = None,
        distinct: Optional[List[types.EntityScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Entity record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Entity filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Entity model
        order
            Order the returned Entity records by any field
        distinct
            Filter Entity records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Entity
            The first Entity record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Entity record ordered by the value field
        entity = await Entity.prisma().find_first(
            skip=1,
            order={
                'value': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EntityWhereInput] = None,
        cursor: Optional[types.EntityWhereUniqueInput] = None,
        include: Optional[types.EntityInclude] = None,
        order: Optional[Union[types.EntityOrderByInput, List[types.EntityOrderByInput]]] = None,
        distinct: Optional[List[types.EntityScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Entity record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Entity filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Entity model
        order
            Order the returned Entity records by any field
        distinct
            Filter Entity records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Entity
            The first Entity record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Entity record ordered by the normalizedValue field
        entity = await Entity.prisma().find_first_or_raise(
            skip=1,
            order={
                'normalizedValue': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.EntityUpdateInput,
        where: types.EntityWhereUniqueInput,
        include: Optional[types.EntityInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Entity record.

        Parameters
        ----------
        data
            Entity record data specifying what to update
        where
            Entity filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Entity model

        Returns
        -------
        prisma.models.Entity
            The updated Entity record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        entity = await Entity.prisma().update(
            where={
                'id': 'bgheaejbcc',
            },
            data={
                # data to update the Entity record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.EntityWhereUniqueInput,
        data: types.EntityUpsertInput,
        include: Optional[types.EntityInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Entity filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Entity model

        Returns
        -------
        prisma.models.Entity
            The created or updated Entity record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        entity = await Entity.prisma().upsert(
            where={
                'id': 'bfcgifeged',
            },
            data={
                'create': {
                    'id': 'bfcgifeged',
                    'userId': 'badaffhddg',
                    'type': 'bbdbfcfihd',
                    'value': 'cbagggbji',
                },
                'update': {
                    'userId': 'badaffhddg',
                    'type': 'bbdbfcfihd',
                    'value': 'cbagggbji',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.EntityUpdateManyMutationInput,
        where: types.EntityWhereInput,
    ) -> int:
        """Update multiple Entity records

        Parameters
        ----------
        data
            Entity data to update the selected Entity records to
        where
            Filter to select the Entity records to update

        Returns
        -------
        int
            The total number of Entity records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Entity records
        total = await Entity.prisma().update_many(
            data={
                'firstSeenAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EntityWhereInput] = None,
        cursor: Optional[types.EntityWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Entity records present in the database

        Parameters
        ----------
        select
            Select the Entity fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Entity filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EntityCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Entity.prisma().count()

        # results: prisma.types.EntityCountAggregateOutput
        results = await Entity.prisma().count(
            select={
                '_all': True,
                'lastSeenAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.EntityCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EntityWhereInput] = None,
        cursor: Optional[types.EntityWhereUniqueInput] = None,
    ) -> types.EntityCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.EntityCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EntityWhereInput] = None,
        cursor: Optional[types.EntityWhereUniqueInput] = None,
    ) -> Union[int, types.EntityCountAggregateOutput]:
        """Count the number of Entity records present in the database

        Parameters
        ----------
        select
            Select the Entity fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Entity filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EntityCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Entity.prisma().count()

        # results: prisma.types.EntityCountAggregateOutput
        results = await Entity.prisma().count(
            select={
                '_all': True,
                'mentionCount': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.EntityCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.EntityWhereInput] = None
    ) -> int:
        """Delete multiple Entity records.

        Parameters
        ----------
        where
            Optional Entity filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Entity records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Entity records
        total = await Entity.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.EntityScalarFieldKeys'],
        *,
        where: Optional['types.EntityWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.EntityAvgAggregateInput'] = None,
        sum: Optional['types.EntitySumAggregateInput'] = None,
        min: Optional['types.EntityMinAggregateInput'] = None,
        max: Optional['types.EntityMaxAggregateInput'] = None,
        having: Optional['types.EntityScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.EntityCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.EntityScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.EntityScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.EntityGroupByOutput']:
        """Group Entity records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Entity fields to group records by
        where
            Entity filter to select records
        take
            Limit the maximum number of Entity records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.EntityGroupByOutput]
            A list of dictionaries representing the Entity record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Entity records by id values
        # and count how many records are in each group
        results = await Entity.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class EntityMentionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.EntityMention]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await EntityMention.prisma().query_raw(
            'SELECT * FROM EntityMention WHERE id = $1',
            'jfiahhbae',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.EntityMention
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await EntityMention.prisma().query_first(
            'SELECT * FROM EntityMention WHERE entityId = $1',
            'bfbdafajcb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.EntityMentionCreateInput,
        include: Optional[types.EntityMentionInclude] = None
    ) -> _PrismaModelT:
        """Create a new EntityMention record.

        Parameters
        ----------
        data
            EntityMention record data
        include
            Specifies which relations should be loaded on the returned EntityMention model

        Returns
        -------
        prisma.models.EntityMention
            The created EntityMention record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a EntityMention record from just the required fields
        entitymention = await EntityMention.prisma().create(
            data={
                # data to create a EntityMention record
                'entityId': 'caeghehde',
                'sessionId': 'caghgfbggd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.EntityMentionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple EntityMention records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of EntityMention record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await EntityMention.prisma().create_many(
            data=[
                {
                    # data to create a EntityMention record
                    'entityId': 'bbidjbbjaa',
                    'sessionId': 'bfijhaejdd',
                },
                {
                    # data to create a EntityMention record
                    'entityId': 'bcedehfiji',
                    'sessionId': 'bdgjicijhb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.EntityMentionWhereUniqueInput,
        include: Optional[types.EntityMentionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single EntityMention record.

        Parameters
        ----------
        where
            EntityMention filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned EntityMention model

        Returns
        -------
        prisma.models.EntityMention
            The deleted EntityMention record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        entitymention = await EntityMention.prisma().delete(
            where={
                'id': 'bghifjdeia',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.EntityMentionWhereUniqueInput,
        include: Optional[types.EntityMentionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique EntityMention record.

        Parameters
        ----------
        where
            EntityMention filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned EntityMention model

        Returns
        -------
        prisma.models.EntityMention
            The found EntityMention record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        entitymention = await EntityMention.prisma().find_unique(
            where={
                'id': 'eadfcbbcb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.EntityMentionWhereUniqueInput,
        include: Optional[types.EntityMentionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique EntityMention record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            EntityMention filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned EntityMention model

        Returns
        -------
        prisma.models.EntityMention
            The found EntityMention record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        entitymention = await EntityMention.prisma().find_unique_or_raise(
            where={
                'id': 'geihgahba',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EntityMentionWhereInput] = None,
        cursor: Optional[types.EntityMentionWhereUniqueInput] = None,
        include: Optional[types.EntityMentionInclude] = None,
        order: Optional[Union[types.EntityMentionOrderByInput, List[types.EntityMentionOrderByInput]]] = None,
        distinct: Optional[List[types.EntityMentionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple EntityMention records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of EntityMention records returned
        skip
            Ignore the first N results
        where
            EntityMention filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EntityMention model
        order
            Order the returned EntityMention records by any field
        distinct
            Filter EntityMention records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.EntityMention]
            The list of all EntityMention records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 EntityMention records
        entitymentions = await EntityMention.prisma().find_many(take=10)

        # find the first 5 EntityMention records ordered by the sessionId field
        entitymentions = await EntityMention.prisma().find_many(
            take=5,
            order={
                'sessionId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EntityMentionWhereInput] = None,
        cursor: Optional[types.EntityMentionWhereUniqueInput] = None,
        include: Optional[types.EntityMentionInclude] = None,
        order: Optional[Union[types.EntityMentionOrderByInput, List[types.EntityMentionOrderByInput]]] = None,
        distinct: Optional[List[types.EntityMentionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single EntityMention record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            EntityMention filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EntityMention model
        order
            Order the returned EntityMention records by any field
        distinct
            Filter EntityMention records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.EntityMention
            The first EntityMention record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second EntityMention record ordered by the context field
        entitymention = await EntityMention.prisma().find_first(
            skip=1,
            order={
                'context': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EntityMentionWhereInput] = None,
        cursor: Optional[types.EntityMentionWhereUniqueInput] = None,
        include: Optional[types.EntityMentionInclude] = None,
        order: Optional[Union[types.EntityMentionOrderByInput, List[types.EntityMentionOrderByInput]]] = None,
        distinct: Optional[List[types.EntityMentionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single EntityMention record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            EntityMention filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EntityMention model
        order
            Order the returned EntityMention records by any field
        distinct
            Filter EntityMention records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.EntityMention
            The first EntityMention record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second EntityMention record ordered by the createdAt field
        entitymention = await EntityMention.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.EntityMentionUpdateInput,
        where: types.EntityMentionWhereUniqueInput,
        include: Optional[types.EntityMentionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single EntityMention record.

        Parameters
        ----------
        data
            EntityMention record data specifying what to update
        where
            EntityMention filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned EntityMention model

        Returns
        -------
        prisma.models.EntityMention
            The updated EntityMention record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        entitymention = await EntityMention.prisma().update(
            where={
                'id': 'gahdcdhbj',
            },
            data={
                # data to update the EntityMention record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.EntityMentionWhereUniqueInput,
        data: types.EntityMentionUpsertInput,
        include: Optional[types.EntityMentionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            EntityMention filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned EntityMention model

        Returns
        -------
        prisma.models.EntityMention
            The created or updated EntityMention record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        entitymention = await EntityMention.prisma().upsert(
            where={
                'id': 'begiijahea',
            },
            data={
                'create': {
                    'id': 'begiijahea',
                    'entityId': 'bcedehfiji',
                    'sessionId': 'bdgjicijhb',
                },
                'update': {
                    'entityId': 'bcedehfiji',
                    'sessionId': 'bdgjicijhb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.EntityMentionUpdateManyMutationInput,
        where: types.EntityMentionWhereInput,
    ) -> int:
        """Update multiple EntityMention records

        Parameters
        ----------
        data
            EntityMention data to update the selected EntityMention records to
        where
            Filter to select the EntityMention records to update

        Returns
        -------
        int
            The total number of EntityMention records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all EntityMention records
        total = await EntityMention.prisma().update_many(
            data={
                'id': 'gcjadjaaf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EntityMentionWhereInput] = None,
        cursor: Optional[types.EntityMentionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of EntityMention records present in the database

        Parameters
        ----------
        select
            Select the EntityMention fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            EntityMention filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EntityMentionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await EntityMention.prisma().count()

        # results: prisma.types.EntityMentionCountAggregateOutput
        results = await EntityMention.prisma().count(
            select={
                '_all': True,
                'entityId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.EntityMentionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EntityMentionWhereInput] = None,
        cursor: Optional[types.EntityMentionWhereUniqueInput] = None,
    ) -> types.EntityMentionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.EntityMentionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EntityMentionWhereInput] = None,
        cursor: Optional[types.EntityMentionWhereUniqueInput] = None,
    ) -> Union[int, types.EntityMentionCountAggregateOutput]:
        """Count the number of EntityMention records present in the database

        Parameters
        ----------
        select
            Select the EntityMention fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            EntityMention filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EntityMentionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await EntityMention.prisma().count()

        # results: prisma.types.EntityMentionCountAggregateOutput
        results = await EntityMention.prisma().count(
            select={
                '_all': True,
                'sessionId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.EntityMentionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.EntityMentionWhereInput] = None
    ) -> int:
        """Delete multiple EntityMention records.

        Parameters
        ----------
        where
            Optional EntityMention filter to find the records to be deleted

        Returns
        -------
        int
            The total number of EntityMention records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all EntityMention records
        total = await EntityMention.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.EntityMentionScalarFieldKeys'],
        *,
        where: Optional['types.EntityMentionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.EntityMentionAvgAggregateInput'] = None,
        sum: Optional['types.EntityMentionSumAggregateInput'] = None,
        min: Optional['types.EntityMentionMinAggregateInput'] = None,
        max: Optional['types.EntityMentionMaxAggregateInput'] = None,
        having: Optional['types.EntityMentionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.EntityMentionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.EntityMentionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.EntityMentionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.EntityMentionGroupByOutput']:
        """Group EntityMention records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar EntityMention fields to group records by
        where
            EntityMention filter to select records
        take
            Limit the maximum number of EntityMention records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.EntityMentionGroupByOutput]
            A list of dictionaries representing the EntityMention record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group EntityMention records by context values
        # and count how many records are in each group
        results = await EntityMention.prisma().group_by(
            ['context'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TagActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Tag]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Tag.prisma().query_raw(
            'SELECT * FROM Tag WHERE id = $1',
            'bcbebgiaic',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Tag
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Tag.prisma().query_first(
            'SELECT * FROM Tag WHERE userId = $1',
            'ijigbdcbj',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TagCreateInput,
        include: Optional[types.TagInclude] = None
    ) -> _PrismaModelT:
        """Create a new Tag record.

        Parameters
        ----------
        data
            Tag record data
        include
            Specifies which relations should be loaded on the returned Tag model

        Returns
        -------
        prisma.models.Tag
            The created Tag record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Tag record from just the required fields
        tag = await Tag.prisma().create(
            data={
                # data to create a Tag record
                'userId': 'gfidhicai',
                'name': 'jfegcaafh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TagCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Tag records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Tag record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Tag.prisma().create_many(
            data=[
                {
                    # data to create a Tag record
                    'userId': 'bcbeiajjfa',
                    'name': 'baehicaajf',
                },
                {
                    # data to create a Tag record
                    'userId': 'bdachdeiga',
                    'name': 'ijdafccef',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TagWhereUniqueInput,
        include: Optional[types.TagInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Tag record.

        Parameters
        ----------
        where
            Tag filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Tag model

        Returns
        -------
        prisma.models.Tag
            The deleted Tag record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tag = await Tag.prisma().delete(
            where={
                'id': 'ciaaiddag',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TagWhereUniqueInput,
        include: Optional[types.TagInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Tag record.

        Parameters
        ----------
        where
            Tag filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Tag model

        Returns
        -------
        prisma.models.Tag
            The found Tag record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tag = await Tag.prisma().find_unique(
            where={
                'id': 'fejggijff',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TagWhereUniqueInput,
        include: Optional[types.TagInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Tag record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Tag filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Tag model

        Returns
        -------
        prisma.models.Tag
            The found Tag record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tag = await Tag.prisma().find_unique_or_raise(
            where={
                'id': 'hghjaaai',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TagWhereInput] = None,
        cursor: Optional[types.TagWhereUniqueInput] = None,
        include: Optional[types.TagInclude] = None,
        order: Optional[Union[types.TagOrderByInput, List[types.TagOrderByInput]]] = None,
        distinct: Optional[List[types.TagScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Tag records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Tag records returned
        skip
            Ignore the first N results
        where
            Tag filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Tag model
        order
            Order the returned Tag records by any field
        distinct
            Filter Tag records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Tag]
            The list of all Tag records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Tag records
        tags = await Tag.prisma().find_many(take=10)

        # find the first 5 Tag records ordered by the name field
        tags = await Tag.prisma().find_many(
            take=5,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TagWhereInput] = None,
        cursor: Optional[types.TagWhereUniqueInput] = None,
        include: Optional[types.TagInclude] = None,
        order: Optional[Union[types.TagOrderByInput, List[types.TagOrderByInput]]] = None,
        distinct: Optional[List[types.TagScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Tag record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Tag filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Tag model
        order
            Order the returned Tag records by any field
        distinct
            Filter Tag records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Tag
            The first Tag record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Tag record ordered by the color field
        tag = await Tag.prisma().find_first(
            skip=1,
            order={
                'color': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TagWhereInput] = None,
        cursor: Optional[types.TagWhereUniqueInput] = None,
        include: Optional[types.TagInclude] = None,
        order: Optional[Union[types.TagOrderByInput, List[types.TagOrderByInput]]] = None,
        distinct: Optional[List[types.TagScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Tag record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Tag filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Tag model
        order
            Order the returned Tag records by any field
        distinct
            Filter Tag records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Tag
            The first Tag record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Tag record ordered by the source field
        tag = await Tag.prisma().find_first_or_raise(
            skip=1,
            order={
                'source': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TagUpdateInput,
        where: types.TagWhereUniqueInput,
        include: Optional[types.TagInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Tag record.

        Parameters
        ----------
        data
            Tag record data specifying what to update
        where
            Tag filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Tag model

        Returns
        -------
        prisma.models.Tag
            The updated Tag record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        tag = await Tag.prisma().update(
            where={
                'id': 'cajicjjdef',
            },
            data={
                # data to update the Tag record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TagWhereUniqueInput,
        data: types.TagUpsertInput,
        include: Optional[types.TagInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Tag filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Tag model

        Returns
        -------
        prisma.models.Tag
            The created or updated Tag record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tag = await Tag.prisma().upsert(
            where={
                'id': 'cefjaadec',
            },
            data={
                'create': {
                    'id': 'cefjaadec',
                    'userId': 'bdachdeiga',
                    'name': 'ijdafccef',
                },
                'update': {
                    'userId': 'bdachdeiga',
                    'name': 'ijdafccef',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TagUpdateManyMutationInput,
        where: types.TagWhereInput,
    ) -> int:
        """Update multiple Tag records

        Parameters
        ----------
        data
            Tag data to update the selected Tag records to
        where
            Filter to select the Tag records to update

        Returns
        -------
        int
            The total number of Tag records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Tag records
        total = await Tag.prisma().update_many(
            data={
                'isVisible': False
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TagWhereInput] = None,
        cursor: Optional[types.TagWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Tag records present in the database

        Parameters
        ----------
        select
            Select the Tag fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Tag filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TagCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Tag.prisma().count()

        # results: prisma.types.TagCountAggregateOutput
        results = await Tag.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TagCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TagWhereInput] = None,
        cursor: Optional[types.TagWhereUniqueInput] = None,
    ) -> types.TagCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TagCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TagWhereInput] = None,
        cursor: Optional[types.TagWhereUniqueInput] = None,
    ) -> Union[int, types.TagCountAggregateOutput]:
        """Count the number of Tag records present in the database

        Parameters
        ----------
        select
            Select the Tag fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Tag filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TagCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Tag.prisma().count()

        # results: prisma.types.TagCountAggregateOutput
        results = await Tag.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TagCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TagWhereInput] = None
    ) -> int:
        """Delete multiple Tag records.

        Parameters
        ----------
        where
            Optional Tag filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Tag records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Tag records
        total = await Tag.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TagScalarFieldKeys'],
        *,
        where: Optional['types.TagWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TagAvgAggregateInput'] = None,
        sum: Optional['types.TagSumAggregateInput'] = None,
        min: Optional['types.TagMinAggregateInput'] = None,
        max: Optional['types.TagMaxAggregateInput'] = None,
        having: Optional['types.TagScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TagCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TagScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TagScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TagGroupByOutput']:
        """Group Tag records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Tag fields to group records by
        where
            Tag filter to select records
        take
            Limit the maximum number of Tag records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TagGroupByOutput]
            A list of dictionaries representing the Tag record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Tag records by userId values
        # and count how many records are in each group
        results = await Tag.prisma().group_by(
            ['userId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class SessionTagActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.SessionTag]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await SessionTag.prisma().query_raw(
            'SELECT * FROM SessionTag WHERE id = $1',
            'bdiiiabbii',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.SessionTag
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await SessionTag.prisma().query_first(
            'SELECT * FROM SessionTag WHERE sessionId = $1',
            'hfcfhhadh',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SessionTagCreateInput,
        include: Optional[types.SessionTagInclude] = None
    ) -> _PrismaModelT:
        """Create a new SessionTag record.

        Parameters
        ----------
        data
            SessionTag record data
        include
            Specifies which relations should be loaded on the returned SessionTag model

        Returns
        -------
        prisma.models.SessionTag
            The created SessionTag record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a SessionTag record from just the required fields
        sessiontag = await SessionTag.prisma().create(
            data={
                # data to create a SessionTag record
                'sessionId': 'bbihggdcji',
                'tagId': 'hgjgibdgd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SessionTagCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple SessionTag records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of SessionTag record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await SessionTag.prisma().create_many(
            data=[
                {
                    # data to create a SessionTag record
                    'sessionId': 'bcbecjfice',
                    'tagId': 'bacbebhjjd',
                },
                {
                    # data to create a SessionTag record
                    'sessionId': 'dfbfaddhe',
                    'tagId': 'bdcbbieibf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SessionTagWhereUniqueInput,
        include: Optional[types.SessionTagInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single SessionTag record.

        Parameters
        ----------
        where
            SessionTag filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned SessionTag model

        Returns
        -------
        prisma.models.SessionTag
            The deleted SessionTag record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        sessiontag = await SessionTag.prisma().delete(
            where={
                'id': 'dgjhdcggi',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SessionTagWhereUniqueInput,
        include: Optional[types.SessionTagInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique SessionTag record.

        Parameters
        ----------
        where
            SessionTag filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned SessionTag model

        Returns
        -------
        prisma.models.SessionTag
            The found SessionTag record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        sessiontag = await SessionTag.prisma().find_unique(
            where={
                'id': 'bbjbcdfabd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SessionTagWhereUniqueInput,
        include: Optional[types.SessionTagInclude] = None
    ) -> _PrismaModelT:
        """Find a unique SessionTag record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            SessionTag filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned SessionTag model

        Returns
        -------
        prisma.models.SessionTag
            The found SessionTag record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        sessiontag = await SessionTag.prisma().find_unique_or_raise(
            where={
                'id': 'gchfgbcec',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SessionTagWhereInput] = None,
        cursor: Optional[types.SessionTagWhereUniqueInput] = None,
        include: Optional[types.SessionTagInclude] = None,
        order: Optional[Union[types.SessionTagOrderByInput, List[types.SessionTagOrderByInput]]] = None,
        distinct: Optional[List[types.SessionTagScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple SessionTag records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of SessionTag records returned
        skip
            Ignore the first N results
        where
            SessionTag filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SessionTag model
        order
            Order the returned SessionTag records by any field
        distinct
            Filter SessionTag records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.SessionTag]
            The list of all SessionTag records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 SessionTag records
        sessiontags = await SessionTag.prisma().find_many(take=10)

        # find the first 5 SessionTag records ordered by the tagId field
        sessiontags = await SessionTag.prisma().find_many(
            take=5,
            order={
                'tagId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SessionTagWhereInput] = None,
        cursor: Optional[types.SessionTagWhereUniqueInput] = None,
        include: Optional[types.SessionTagInclude] = None,
        order: Optional[Union[types.SessionTagOrderByInput, List[types.SessionTagOrderByInput]]] = None,
        distinct: Optional[List[types.SessionTagScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single SessionTag record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            SessionTag filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SessionTag model
        order
            Order the returned SessionTag records by any field
        distinct
            Filter SessionTag records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.SessionTag
            The first SessionTag record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second SessionTag record ordered by the createdAt field
        sessiontag = await SessionTag.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SessionTagWhereInput] = None,
        cursor: Optional[types.SessionTagWhereUniqueInput] = None,
        include: Optional[types.SessionTagInclude] = None,
        order: Optional[Union[types.SessionTagOrderByInput, List[types.SessionTagOrderByInput]]] = None,
        distinct: Optional[List[types.SessionTagScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single SessionTag record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            SessionTag filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SessionTag model
        order
            Order the returned SessionTag records by any field
        distinct
            Filter SessionTag records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.SessionTag
            The first SessionTag record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second SessionTag record ordered by the id field
        sessiontag = await SessionTag.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SessionTagUpdateInput,
        where: types.SessionTagWhereUniqueInput,
        include: Optional[types.SessionTagInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single SessionTag record.

        Parameters
        ----------
        data
            SessionTag record data specifying what to update
        where
            SessionTag filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned SessionTag model

        Returns
        -------
        prisma.models.SessionTag
            The updated SessionTag record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        sessiontag = await SessionTag.prisma().update(
            where={
                'id': 'bihcjfcjah',
            },
            data={
                # data to update the SessionTag record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SessionTagWhereUniqueInput,
        data: types.SessionTagUpsertInput,
        include: Optional[types.SessionTagInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            SessionTag filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned SessionTag model

        Returns
        -------
        prisma.models.SessionTag
            The created or updated SessionTag record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        sessiontag = await SessionTag.prisma().upsert(
            where={
                'id': 'bhjdcicaii',
            },
            data={
                'create': {
                    'id': 'bhjdcicaii',
                    'sessionId': 'dfbfaddhe',
                    'tagId': 'bdcbbieibf',
                },
                'update': {
                    'sessionId': 'dfbfaddhe',
                    'tagId': 'bdcbbieibf',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SessionTagUpdateManyMutationInput,
        where: types.SessionTagWhereInput,
    ) -> int:
        """Update multiple SessionTag records

        Parameters
        ----------
        data
            SessionTag data to update the selected SessionTag records to
        where
            Filter to select the SessionTag records to update

        Returns
        -------
        int
            The total number of SessionTag records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all SessionTag records
        total = await SessionTag.prisma().update_many(
            data={
                'sessionId': 'bibedjhcej'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SessionTagWhereInput] = None,
        cursor: Optional[types.SessionTagWhereUniqueInput] = None,
    ) -> int:
        """Count the number of SessionTag records present in the database

        Parameters
        ----------
        select
            Select the SessionTag fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            SessionTag filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SessionTagCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await SessionTag.prisma().count()

        # results: prisma.types.SessionTagCountAggregateOutput
        results = await SessionTag.prisma().count(
            select={
                '_all': True,
                'tagId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SessionTagCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SessionTagWhereInput] = None,
        cursor: Optional[types.SessionTagWhereUniqueInput] = None,
    ) -> types.SessionTagCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SessionTagCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SessionTagWhereInput] = None,
        cursor: Optional[types.SessionTagWhereUniqueInput] = None,
    ) -> Union[int, types.SessionTagCountAggregateOutput]:
        """Count the number of SessionTag records present in the database

        Parameters
        ----------
        select
            Select the SessionTag fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            SessionTag filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SessionTagCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await SessionTag.prisma().count()

        # results: prisma.types.SessionTagCountAggregateOutput
        results = await SessionTag.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SessionTagCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SessionTagWhereInput] = None
    ) -> int:
        """Delete multiple SessionTag records.

        Parameters
        ----------
        where
            Optional SessionTag filter to find the records to be deleted

        Returns
        -------
        int
            The total number of SessionTag records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all SessionTag records
        total = await SessionTag.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SessionTagScalarFieldKeys'],
        *,
        where: Optional['types.SessionTagWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SessionTagAvgAggregateInput'] = None,
        sum: Optional['types.SessionTagSumAggregateInput'] = None,
        min: Optional['types.SessionTagMinAggregateInput'] = None,
        max: Optional['types.SessionTagMaxAggregateInput'] = None,
        having: Optional['types.SessionTagScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SessionTagCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SessionTagScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.SessionTagScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.SessionTagGroupByOutput']:
        """Group SessionTag records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar SessionTag fields to group records by
        where
            SessionTag filter to select records
        take
            Limit the maximum number of SessionTag records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SessionTagGroupByOutput]
            A list of dictionaries representing the SessionTag record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group SessionTag records by id values
        # and count how many records are in each group
        results = await SessionTag.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UsageLogActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UsageLog]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UsageLog.prisma().query_raw(
            'SELECT * FROM UsageLog WHERE id = $1',
            'bjcdajabfa',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UsageLog
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UsageLog.prisma().query_first(
            'SELECT * FROM UsageLog WHERE userId = $1',
            'bchhceeeff',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UsageLogCreateInput,
        include: Optional[types.UsageLogInclude] = None
    ) -> _PrismaModelT:
        """Create a new UsageLog record.

        Parameters
        ----------
        data
            UsageLog record data
        include
            Specifies which relations should be loaded on the returned UsageLog model

        Returns
        -------
        prisma.models.UsageLog
            The created UsageLog record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UsageLog record from just the required fields
        usagelog = await UsageLog.prisma().create(
            data={
                # data to create a UsageLog record
                'userId': 'bbgaifhdaa',
                'sessionId': 'dgbcdaegb',
                'minutes': 1406511986.148287,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UsageLogCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UsageLog records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UsageLog record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UsageLog.prisma().create_many(
            data=[
                {
                    # data to create a UsageLog record
                    'userId': 'fgggcdcjg',
                    'sessionId': 'ccjbbjigf',
                    'minutes': 1750011070.41094,
                },
                {
                    # data to create a UsageLog record
                    'userId': 'jajacedge',
                    'sessionId': 'hffgbabgf',
                    'minutes': 1802188490.29491,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UsageLogWhereUniqueInput,
        include: Optional[types.UsageLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UsageLog record.

        Parameters
        ----------
        where
            UsageLog filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UsageLog model

        Returns
        -------
        prisma.models.UsageLog
            The deleted UsageLog record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usagelog = await UsageLog.prisma().delete(
            where={
                'id': 'fgeahddae',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UsageLogWhereUniqueInput,
        include: Optional[types.UsageLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UsageLog record.

        Parameters
        ----------
        where
            UsageLog filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UsageLog model

        Returns
        -------
        prisma.models.UsageLog
            The found UsageLog record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usagelog = await UsageLog.prisma().find_unique(
            where={
                'id': 'diageigcf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UsageLogWhereUniqueInput,
        include: Optional[types.UsageLogInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UsageLog record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UsageLog filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UsageLog model

        Returns
        -------
        prisma.models.UsageLog
            The found UsageLog record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usagelog = await UsageLog.prisma().find_unique_or_raise(
            where={
                'id': 'badagbgeha',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UsageLogWhereInput] = None,
        cursor: Optional[types.UsageLogWhereUniqueInput] = None,
        include: Optional[types.UsageLogInclude] = None,
        order: Optional[Union[types.UsageLogOrderByInput, List[types.UsageLogOrderByInput]]] = None,
        distinct: Optional[List[types.UsageLogScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UsageLog records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UsageLog records returned
        skip
            Ignore the first N results
        where
            UsageLog filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UsageLog model
        order
            Order the returned UsageLog records by any field
        distinct
            Filter UsageLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UsageLog]
            The list of all UsageLog records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UsageLog records
        usagelogs = await UsageLog.prisma().find_many(take=10)

        # find the first 5 UsageLog records ordered by the sessionId field
        usagelogs = await UsageLog.prisma().find_many(
            take=5,
            order={
                'sessionId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UsageLogWhereInput] = None,
        cursor: Optional[types.UsageLogWhereUniqueInput] = None,
        include: Optional[types.UsageLogInclude] = None,
        order: Optional[Union[types.UsageLogOrderByInput, List[types.UsageLogOrderByInput]]] = None,
        distinct: Optional[List[types.UsageLogScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UsageLog record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UsageLog filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UsageLog model
        order
            Order the returned UsageLog records by any field
        distinct
            Filter UsageLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UsageLog
            The first UsageLog record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UsageLog record ordered by the minutes field
        usagelog = await UsageLog.prisma().find_first(
            skip=1,
            order={
                'minutes': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UsageLogWhereInput] = None,
        cursor: Optional[types.UsageLogWhereUniqueInput] = None,
        include: Optional[types.UsageLogInclude] = None,
        order: Optional[Union[types.UsageLogOrderByInput, List[types.UsageLogOrderByInput]]] = None,
        distinct: Optional[List[types.UsageLogScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UsageLog record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UsageLog filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UsageLog model
        order
            Order the returned UsageLog records by any field
        distinct
            Filter UsageLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UsageLog
            The first UsageLog record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UsageLog record ordered by the createdAt field
        usagelog = await UsageLog.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UsageLogUpdateInput,
        where: types.UsageLogWhereUniqueInput,
        include: Optional[types.UsageLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UsageLog record.

        Parameters
        ----------
        data
            UsageLog record data specifying what to update
        where
            UsageLog filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UsageLog model

        Returns
        -------
        prisma.models.UsageLog
            The updated UsageLog record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        usagelog = await UsageLog.prisma().update(
            where={
                'id': 'ibgebbjch',
            },
            data={
                # data to update the UsageLog record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UsageLogWhereUniqueInput,
        data: types.UsageLogUpsertInput,
        include: Optional[types.UsageLogInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UsageLog filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UsageLog model

        Returns
        -------
        prisma.models.UsageLog
            The created or updated UsageLog record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usagelog = await UsageLog.prisma().upsert(
            where={
                'id': 'baieajjiee',
            },
            data={
                'create': {
                    'id': 'baieajjiee',
                    'userId': 'jajacedge',
                    'sessionId': 'hffgbabgf',
                    'minutes': 1802188490.29491,
                },
                'update': {
                    'userId': 'jajacedge',
                    'sessionId': 'hffgbabgf',
                    'minutes': 1802188490.29491,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UsageLogUpdateManyMutationInput,
        where: types.UsageLogWhereInput,
    ) -> int:
        """Update multiple UsageLog records

        Parameters
        ----------
        data
            UsageLog data to update the selected UsageLog records to
        where
            Filter to select the UsageLog records to update

        Returns
        -------
        int
            The total number of UsageLog records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UsageLog records
        total = await UsageLog.prisma().update_many(
            data={
                'id': 'bahjhaccfd'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UsageLogWhereInput] = None,
        cursor: Optional[types.UsageLogWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UsageLog records present in the database

        Parameters
        ----------
        select
            Select the UsageLog fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UsageLog filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UsageLogCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UsageLog.prisma().count()

        # results: prisma.types.UsageLogCountAggregateOutput
        results = await UsageLog.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UsageLogCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UsageLogWhereInput] = None,
        cursor: Optional[types.UsageLogWhereUniqueInput] = None,
    ) -> types.UsageLogCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UsageLogCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UsageLogWhereInput] = None,
        cursor: Optional[types.UsageLogWhereUniqueInput] = None,
    ) -> Union[int, types.UsageLogCountAggregateOutput]:
        """Count the number of UsageLog records present in the database

        Parameters
        ----------
        select
            Select the UsageLog fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UsageLog filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UsageLogCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UsageLog.prisma().count()

        # results: prisma.types.UsageLogCountAggregateOutput
        results = await UsageLog.prisma().count(
            select={
                '_all': True,
                'sessionId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UsageLogCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UsageLogWhereInput] = None
    ) -> int:
        """Delete multiple UsageLog records.

        Parameters
        ----------
        where
            Optional UsageLog filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UsageLog records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UsageLog records
        total = await UsageLog.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UsageLogScalarFieldKeys'],
        *,
        where: Optional['types.UsageLogWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UsageLogAvgAggregateInput'] = None,
        sum: Optional['types.UsageLogSumAggregateInput'] = None,
        min: Optional['types.UsageLogMinAggregateInput'] = None,
        max: Optional['types.UsageLogMaxAggregateInput'] = None,
        having: Optional['types.UsageLogScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UsageLogCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UsageLogScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UsageLogScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UsageLogGroupByOutput']:
        """Group UsageLog records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UsageLog fields to group records by
        where
            UsageLog filter to select records
        take
            Limit the maximum number of UsageLog records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UsageLogGroupByOutput]
            A list of dictionaries representing the UsageLog record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UsageLog records by minutes values
        # and count how many records are in each group
        results = await UsageLog.prisma().group_by(
            ['minutes'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models